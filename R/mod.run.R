#' Run and evaluate a population PK model
#'
#' Generates the model, fits it with \pkg{nlmixr2} (SAEM), computes a penalized
#' fitness, and appends results to a persistent \code{.csv} to avoid redundant runs.
#'
#' @param modi Integer. Model identifier (also used to name generated code files).
#' @param string Numeric/integer vector encoding the model structure. For
#'   \code{search.space = "ivbase"} it is expected to contain indicators in the
#'   order used by \code{ppkmodGen()} (e.g., \code{no.cmpt}, \code{eta.km},
#'   \code{eta.cl}, \code{eta.vc}, \code{eta.vp}, \code{eta.vp2}, \code{eta.q},
#'   \code{eta.q2}, \code{mm}, \code{mcorr}, \code{rv}). For
#'   \code{"oralbase"} an additional \code{eta.ka} element is expected. See Details.
#' @param dat Data frame of observations (columns as required by \pkg{nlmixr2}/\pkg{rxode2},
#'   e.g., \code{ID}, \code{TIME}, \code{DV}, dosing records with \code{EVID}, etc.).
#' @param search.space Character, either \code{"ivbase"} (intravenous) or
#'   \code{"oralbase"} (oral). Determines route and which indices in \code{string}
#'   are parsed into the model.
#' @param penalty.control List created by \code{\link{penaltyControl}()} defining
#'   penalties for boundary hits, large RSE, high shrinkage, convergence flags, etc.
#' @param param_table Data frame of initial estimates. If \code{NULL}, it is
#'   generated by \code{\link{auto_param_table}()} (optionally using
#'   \code{nlmixr2autoinits} helpers).
#' @param nlmixr2autoinits Logical. Whether to auto-initialize parameters via
#'   \pkg{nlmixr2} helpers when building \code{param_table}.
#' @param reuse_cache Integer/logical. If \code{TRUE}/\code{1}, attempt to load
#'   precomputed results (see \code{precomputed_results_file}/\code{filename}).
#' @param precomputed_results_file Character or \code{NULL}. Path to a CSV of
#'   previously computed results to be searched for cache hits.
#' @param filename Character or \code{NULL}. Basename (without \code{.csv}) to
#'   which the running history \emph{will be appended}. If \code{NULL}, results
#'   are kept in memory only.
#' @param ... Additional controls passed through, notably
#'   \code{saem.control = nlmixr2::saemControl(...)} and
#'   \code{table.control = nlmixr2::tableControl(...)}.
#'
#' @return Numeric scalar: the penalized fitness for the evaluated model.
#'
#' @details
#' The function constructs a structural model from \code{string} via
#' \code{\link{ppkmodGen}()}, \code{source()}s the generated code (defining \code{f}),
#' and fits by SAEM (\code{\link[nlmixr2]{saem}}) to produce a likelihood-based fit.
#' Fitness is then adjusted by penalties (e.g., excessive relative standard errors,
#' large \emph{EBE} shrinkage, boundary hits, convergence flags). For MM
#' (Michaelis–Menten) elimination, \code{mm = 1} toggles \code{eta.vmax}/\code{eta.cl}
#' inclusion as mutually exclusive components.
#'
#' The function maintains an in-memory history (\code{Store.all}) and, when
#' \code{filename} is provided, also appends to \code{<filename>.csv}. If a model
#' with identical structural “key” is found in cache, the stored fitness is
#' returned without re-fitting.
#'
#' @section Side effects:
#' Writes/updates \code{<filename>.csv} when \code{filename} is non-empty; also
#' modifies global objects such as \code{Store.all} and a cache of precomputed
#' results when enabled.
#'
#' @seealso
#' \code{\link{ppkmodGen}}, \code{\link{penaltyControl}},
#' \code{\link{auto_param_table}},
#' \code{\link[nlmixr2]{saemControl}},
#' \code{\link[nlmixr2]{tableControl}},
#' \code{\link[rxode2]{rxSolve}}
#'
#'
#' @import rxode2
#' @import nlmixr2
#' @import crayon
#' @import stringr
#'
#' @examples
#' \dontrun{
#' dat <- pheno_sd
#' # Example IV base structure (10 elements; mm at position 9 in this layout):
#' string <- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 1)
#' param_table <- auto_param_table(dat = dat, nlmixr2autoinits = TRUE)
#' fit_val <- mod.run(
#'   modi = 1,
#'   string = string,
#'   dat = dat,
#'   search.space = "ivbase",
#'   param_table = param_table,
#'   filename = "sim_results",
#'   saem.control = nlmixr2::saemControl(logLik = TRUE)
#' )
#' }
#'
#' @export



mod.run <- function(string = NULL,
                    dat = NULL,
                    search.space = "ivbase",
                    penalty.control = penaltyControl(),
                    param_table = NULL,
                    nlmixr2autoinits = TRUE,
                    reuse_cache = 1,
                    precomputed_results_file = NULL,
                    filename=NULL,
                    ...) {

  # Ensure global counters exist
  if (!exists("modi", envir = .GlobalEnv))
    assign("modi", 1, envir = .GlobalEnv)
  if (!exists("r", envir = .GlobalEnv))
    assign("r", 1, envir = .GlobalEnv)
  if (!exists("Store.all", envir = .GlobalEnv))
    assign("Store.all", NULL, envir = .GlobalEnv)
  if (!exists("precomputed_cache_loaded", envir = .GlobalEnv))
    assign("precomputed_cache_loaded", FALSE, envir = .GlobalEnv)

  if (isTRUE(reuse_cache == 1) && !isTRUE(precomputed_cache_loaded)) {
    if (!is.null(precomputed_results_file) &&
        is.character(precomputed_results_file) &&
        nzchar(precomputed_results_file)) {
      csv_path <- precomputed_results_file
    } else if (exists("filename")) {
      csv_path <- paste0(filename, ".csv")
    } else {
      csv_path <- NULL
    }

    # Attempt to load once (success or not, we mark as loaded to avoid future attempts).
    if (!is.null(csv_path) && file.exists(csv_path)) {
      tmp <- read.csv(csv_path, stringsAsFactors = FALSE)
      if ("current.time" %in% names(tmp)) {
        suppressWarnings({
          tmp$current.time <- as.POSIXct(
            tmp$current.time,
            tryFormats = c(
              "%Y-%m-%d %H:%M:%S",
              "%Y-%m-%d %H:%M",
              "%Y/%m/%d %H:%M:%S"
            )
          )
        })
      }
      precomputed_results <<- tmp
      message(sprintf("Loaded cached model results from '%s'.", csv_path))
    } else {
      precomputed_results <<- NULL
    }
    precomputed_cache_loaded <<- TRUE
  }

  # (1) Auto-generate parameter table if missing
  if (is.null(param_table)) {
    param_table <- auto_param_table(dat = dat, nlmixr2autoinits = TRUE)
  }

  # (2) Build model arguments and generate code file (defines `f` when sourced)
  if (search.space == "ivbase") {
    route <- "bolus"
    mm_val <- as.numeric(string[8])
    eta.vmax_val <- if (mm_val == 0) 0 else 1
    eta.cl_val   <- if (mm_val == 1) 0 else 1
    mod_args <- list(
      modi = modi,
      no.cmpt = string[1],
      eta.vmax = eta.vmax_val,
      eta.km  = string[2],
      eta.cl  = eta.cl_val,
      eta.vc = string[3],
      eta.vp = string[4],
      eta.vp2 = string[5],
      eta.q = string[6],
      eta.q2 = string[7],
      mm = string[8],
      mcorr = string[9],
      rv = string[10],
      route = route,
      param_table = param_table
    )
    do.call(ppkmodGen, mod_args)
    source(paste0("mod", modi, ".txt"))
  } else if (search.space == "oralbase") {
    route <- "oral"
    mm_val <- as.numeric(string[9])
    eta.vmax_val <- if (mm_val == 0) 0 else 1
    eta.cl_val   <- if (mm_val == 1) 0 else 1

    mod_args <- list(
      modi = modi,
      no.cmpt = string[1],
      eta.vmax =  eta.vmax_val,
      eta.km  = string[2],
      eta.cl  = eta.cl_val,
      eta.vc = string[3],
      eta.vp = string[4],
      eta.vp2 = string[5],
      eta.q = string[6],
      eta.q2 = string[7],
      eta.ka = string[8],
      mm = string[9],
      mcorr = string[10],
      rv = string[11],
      route = route,
      param_table = param_table
    )
    do.call(ppkmodGen, mod_args)
    source(paste0("mod", modi, ".txt"))
  } else {
    stop("search.space must be 'ivbase' or 'oralbase'.")
  }

  # reuse a cached fit
  have_cached_fit <- FALSE

  if (exists("Store.all") &&
      !is.null(Store.all) && nrow(Store.all) > 0) {
    model.code.columns <-
      setdiff(names(mod_args), c("modi", "route", "param_table"))

    cols_present <- intersect(model.code.columns, names(Store.all))
    if (length(cols_present) == length(model.code.columns)) {
      # Build keys
      stored_keys <-
        do.call(paste, c(Store.all[model.code.columns], sep = "_"))
      current_key <-
        paste(mod_args[model.code.columns], collapse = "_")

      match.idx <- which(stored_keys == current_key)
      if (length(match.idx) > 0) {
        fit_row <- Store.all[match.idx[1], , drop = FALSE]

        # Keep only raw fit stats
        drop_cols <- unique(c(
          model.code.columns,
          "fitness",
          grep("^flag\\.", names(fit_row), value = TRUE),
          grep("^count\\.constraint\\.", names(fit_row), value = TRUE)
        ))
        Store. <-
          fit_row[, setdiff(names(fit_row), drop_cols), drop = FALSE]

        have_cached_fit <- TRUE
      }
    }
  }

  if (!have_cached_fit &&
      exists("precomputed_results") &&
      !is.null(precomputed_results) &&
      nrow(precomputed_results) > 0) {
    model.code.columns <-
      setdiff(names(mod_args), c("modi", "route", "param_table"))
    cols_present <-
      intersect(model.code.columns, names(precomputed_results))
    if (length(cols_present) == length(model.code.columns)) {
      stored_keys <-
        do.call(paste, c(precomputed_results[model.code.columns], sep = "_"))
      current_key <-
        paste(mod_args[model.code.columns], collapse = "_")

      match.idx <- which(stored_keys == current_key)
      if (length(match.idx) > 0) {
        Store. <- precomputed_results[match.idx[1], , drop = FALSE]
        have_cached_fit <- TRUE
      }
    }
  }

  if (!have_cached_fit) {
    dot_args <- list(...)
    saem.control <- if (!is.null(dot_args$saem.control)) {
      dot_args$saem.control
    } else {
      saemControl(
        seed = 1234,
        print = 5,
        rxControl = rxControl(cores = 4),
        logLik = TRUE
      )
    }
    table.control <- if (!is.null(dot_args$table.control)) {
      dot_args$table.control
    } else {
      tableControl(cwres = TRUE)
    }

    result <- run_model_in_subprocess(
      modi = modi,
      dat = dat,
      f = f,
      saem.control = saem.control,
      table.control = table.control
    )
    fit.s  <- result$fit.s
    Store. <- get.mod.lst(fit.s, modi = modi)
  }

  if (search.space == "ivbase") {
    selected_vars <-
      c(
        "no.cmpt",
        "eta.vmax",
        "eta.km",
        "eta.cl",
        "eta.vc",
        "eta.vp",
        "eta.vp2",
        "eta.q",
        "eta.q2",
        "mm",
        "mcorr",
        "rv"
      )
    for (var in selected_vars) {
      Store.[[var]] <- mod_args[[var]]
    }
    # Penalty analysis
    Store2 <- fitness(
      search.space = search.space,
      fit = Store.,
      dat = dat,
      penalty.control = penalty.control
    )
    Store2$model.num <- modi
    Store2$round.num <- r
    Store2$current.time <- Sys.time()
  }

  if (search.space == "oralbase") {
    selected_vars <-
      c(
        "no.cmpt",
        "eta.vmax",
        "eta.km",
        "eta.cl",
        "eta.vc",
        "eta.vp",
        "eta.vp2",
        "eta.q",
        "eta.q2",
        "eta.ka",
        "mm",
        "mcorr",
        "rv"
      )
    for (var in selected_vars) {
      Store.[[var]] <- mod_args[[var]]
    }

    # Penalty analysis
    Store2 <- fitness(
      search.space = search.space,
      fit =  Store.,
      dat = dat,
      penalty.control = penalty.control
    )
    Store2$model.num <- modi
    Store2$round.num <- r
    Store2$current.time <- Sys.time()
  }

  # (8) Append to Store.all (global)
  if (!exists("Store.all") || is.null(Store.all)) {
    Store.all <<- Store2
  } else {
    Store.all <<- rbind(Store.all, Store2)
  }

  rownames(Store.all)<-seq(1,nrow(Store.all),1)
  write.csv(Store.all, paste0(filename, ".csv"), row.names = FALSE)

  modi <<- modi + 1
  return(Store2$fitness)
}
