#' Control Parameters for Genetic Algorithm
#'
#' Creates a list of control settings for the \code{\link{ga.operator}} function.
#' These settings define the size, number of generations, and probabilities
#' for crossover and mutation, as well as other algorithm behavior parameters.
#'
#' @param npopsize Integer. The number of individuals (chromosomes) in the
#'   population for each generation.
#' @param max.iter Integer. The maximum number of generations to run the GA.
#' @param prob.crossover Numeric in \eqn{[0, 1]}. Probability of performing
#'   crossover between two selected parents.
#' @param prob.mutation Numeric in \eqn{[0, 1]}. Probability of mutating each
#'   bit in a chromosome.
#' @param sig.diff Numeric. Minimum significant fitness difference used when
#'   ranking individuals (passed to \code{\link{rank_new}}).
#' @param nlocal.search Integer. Frequency (in generations) of running local
#'   exhaustive search around the best current model.
#'
#' @return A list of GA control parameters, suitable for passing to
#'   \code{\link{ga.operator}} via its \code{ga.control} argument.
#'
#' @seealso \code{\link{ga.operator}}, \code{\link{rank_new}}, \code{\link{runlocal}}
#'
#' @examples
#' # Default settings
#' gaControl()
#'
#' # Custom GA configuration
#' gaControl(
#'   npopsize = 20,
#'   max.iter = 50,
#'   prob.crossover = 0.9,
#'   prob.mutation = 0.05,
#'   sig.diff = 0.5,
#'   nlocal.search = 10
#' )
#'
#' @export

gaControl <- function(
    npopsize       = 20,
    max.iter       = 20,
    prob.crossover = 0.7,
    prob.mutation  = 0.1,
    sig.diff       = 1,
    nlocal.search  = 3
) {
  list(
    npopsize       = npopsize,
    max.iter       = max.iter,
    prob.crossover = prob.crossover,
    prob.mutation  = prob.mutation,
    sig.diff       = sig.diff,
    nlocal.search  = nlocal.search
  )
}

#' Genetic Algorithm for Model Structure Optimization
#'
#' Executes a genetic algorithm (GA) to search for the optimal pharmacokinetic
#' (PK) model structure within a defined \code{search.space} using
#' \pkg{nlmixr2} fitting and user-defined penalties. The algorithm iteratively
#' evolves a population of candidate model encodings through selection,
#' crossover, mutation, and optional local search to improve model fitness.
#'
#' @param dat A data frame containing the observed PK data, with columns
#'   required by \pkg{nlmixr2} / \pkg{rxode2} (\code{ID}, \code{TIME},
#'   \code{DV}, dosing records with \code{EVID}, etc.).
#' @param param_table Optional data frame of initial parameter estimates.
#'   If \code{NULL}, the table will be auto-generated by
#'   \code{\link{auto_param_table}()}.
#' @param search.space Character string specifying the model search space:
#'   \itemize{
#'     \item \code{"ivbase"} — intravenous base model
#'     \item \code{"oralbase"} — oral base model
#'   }
#' @param no.cores Integer. Number of CPU cores to use for fitting
#'   (passed to \code{rxControl(cores = ...)}).
#' @param foldername Character string for output folder name.
#' @param filename Character string for results file prefix. The run history is
#'   saved to \code{<filename>.csv}.
#' @param ga.control A list created by \code{\link{gaControl}()} specifying
#'   GA hyperparameters: \code{npopsize}, \code{max.iter}, \code{prob.crossover},
#'   \code{prob.mutation}, \code{sig.diff}, \code{nlocal.search}.
#' @param penalty.control A list created by \code{\link{penaltyControl}()}
#'   defining penalty values for poor model diagnostics (boundary hits,
#'   large shrinkage, high RSE, etc.).
#' @param precomputed_results_file Optional path to a CSV of previously computed
#'   model results for caching and avoiding redundant runs.
#' @param seed.no Integer random seed for reproducibility of GA operations
#'   (initialization, crossover, mutation, and local search).
#' @param ... Additional arguments passed to \code{mod.run()}.
#'
#' @details
#' The genetic algorithm performs the following steps per generation:
#' \enumerate{
#'   \item **Population Initialization** — Create a random binary matrix
#'         representing candidate models.
#'   \item **Validation** — Convert binary encodings to valid model codes
#'         using \code{\link{validateModels}()}.
#'   \item **Fitness Evaluation** — Run each model with \code{\link{mod.run}()}
#'         and apply penalties.
#'   \item **Selection** — Tournament selection of parents.
#'   \item **Crossover** — Swap segments of parent chromosomes to create children.
#'   \item **Mutation** — Flip bits at positions with probability
#'         \code{prob.mutation}.
#'   \item **Local Search** — Every \code{nlocal.search} iterations, perform
#'         exhaustive neighbor search around the current best model.
#'   \item **Elitism** — Carry the best individual forward to the next generation.
#' }
#'
#' The algorithm continues for \code{max.iter} generations or until manually
#' stopped. Fitness values are stored in a global \code{Store.all} and written
#' to disk if \code{filename} is provided.
#'
#' @return An object of class \code{"gaOperatorResult"}, which is a list
#'   containing:
#'   \itemize{
#'     \item \code{$Final Selected Code} — Binary vector for the best model.
#'     \item \code{$Final Selected Model Name} — Human-readable model identifier.
#'     \item \code{$Model Run History} — Data frame of all fitted models and fitness values.
#'     \item \code{$Selection History} — List of population, fitness, and offspring
#'           data for each generation.
#'   }
#'
#' @seealso
#'   \code{\link{mod.run}}, \code{\link{gaControl}}, \code{\link{penaltyControl}},
#'   \code{\link{validateModels}}, \code{\link{ga.sel.tournament}},
#'   \code{\link{ga.crossover}}, \code{\link{ga.mutation}}, \code{\link{runlocal}}
#'
#' @examples
#' \dontrun{
#' dat <- pheno_sd
#' result <- ga.operator(
#'   dat = dat,
#'   search.space = "ivbase",
#'   ga.control = gaControl(max.iter = 5, npopsize = 10),
#'   penalty.control = penaltyControl(),
#'   filename = "pheno_sd_test",
#'   seed.no = 1234,
#'   saem.control=saemControl(nBurn = 10,nEm = 10)
#' )
#' print(result)
#' }
#'
#' @export

ga.operator <- function(dat,
                        param_table=NULL,
                        search.space="ivbase",
                        no.cores = rxode2::getRxThreads(),
                        foldername = "test",
                        filename = "test",
                        ga.control=gaControl(),
                        penalty.control=penaltyControl(),
                        precomputed_results_file=NULL,
                        seed.no=1234,
                        ...) {
  #####################Create temporary storage folder for output###############
  current.date <- Sys.Date()
  set.seed(seed.no)

  outputdir <-
    paste0("GA_",
           current.date,
           "-",
           foldername,
           "_",
           digest::digest(dat),
           "_temp")

  if (!dir.exists(outputdir)) {
    dir.create(outputdir, showWarnings = FALSE, recursive = TRUE)
  } else {
    message(
      sprintf(
        "Output directory '%s' already exists. Using existing directory.",
        outputdir
      )
    )
  }

  npopsize       <- ga.control$npopsize
  max.iter       <- ga.control$max.iter
  prob.crossover <- ga.control$prob.crossover
  prob.mutation  <- ga.control$prob.mutation
  sig.diff       <- ga.control$sig.diff
  nlocal.search  <- ga.control$nlocal.search

  setwd(paste0(getwd(), "/", outputdir))
  storage.path <- getwd()
  #################################Initial estimate###############################

  param_table <- auto_param_table(
    dat = dat,
    param_table = param_table,
    nlmixr2autoinits = T,
    foldername = foldername
  )
  # Global variable for model and round number run index

  ##########Search Space Definiation ###########################################
  if (search.space == "ivbase") {
    bit.names <- c(
      "no.cmpt1",   # IV compartment code 1
      "no.cmpt2",   # IV compartment code 2
      "eta.km",     # Eta on Michaelis–Menten constant Km
      "eta.vc",     # Eta on central volume of distribution
      "eta.vp",     # Eta on peripheral volume 1
      "eta.vp2",    # Eta on peripheral volume 2
      "eta.q",      # Eta on intercompartmental clearance 1
      "eta.q2",     # Eta on intercompartmental clearance 2
      "mm",         # Michaelis–Menten elimination included
      "mcorr",      # Random effect correlation included
      "rv1",        # Residual error code 1
      "rv2"         # Residual error code 2
    )

  } else if (search.space == "oralbase") {
    bit.names <- c(
      "no.cmpt1",   # Oral compartment 1
      "no.cmpt2",   # Oral compartment 2
      "eta.km",     # Eta on Michaelis–Menten constant Km
      "eta.vc",     # Eta on central volume of distribution
      "eta.vp",     # Eta on peripheral volume 1
      "eta.vp2",    # Eta on peripheral volume 2
      "eta.q",      # Eta on intercompartmental clearance 1
      "eta.q2",     # Eta on intercompartmental clearance 2
      "eta.ka",     # Eta on absorption rate constant ka
      "mm",         # Michaelis–Menten elimination included
      "mcorr",      # Random effect correlation included
      "rv1",        # Residual error code 1
      "rv2"         # Residual error code 2
    )

  } else {
    stop("Unknown search.space type: must be 'ivbase' or 'oralbase'")
  }

  nbits <- length(bit.names)  # Total number of bits in the chromosome

  # --- GA Main Loop ---
  # Runs genetic algorithm over multiple generations:
  # 1) Init/update population
  # 2) Decode to valid models
  # 3) Evaluate fitness (mod.run + penalty.control)
  # 4) Local search every nlocal.search gens
  # 5) Selection → crossover → mutation
  # 6) Elitism: keep best model
  # 7) Save iteration results in history

  history <- vector("list", max.iter)  # Store results for each iteration

  pb <-
    progress::progress_bar$new(
      format = " GA Search [:bar] :percent (iteration :current/:total)\n",
      total = max.iter,
      clear = FALSE,
      width = 60
    )

  for (ga.iter in 1:max.iter) {
    # 1. Initialize or update population
    if (ga.iter == 1) {
      population <-
        create.pop(npopsize, nbits)   # Initial random population
    } else {
      population <-
        children.all                  # Offspring from previous generation
    }

    colnames(population) <- bit.names

    population <- t(vapply(seq_len(nrow(population)),
                           function(i)
                             validateModels(
                               string = population[i,],
                               search.space = search.space,
                               code.source = "GA"
                             ),
                           numeric(nbits)))

    colnames(population) <- bit.names
    # 3. Model running and fitness evaluation
    data.pop <- as.data.frame(population)

    data.pop$fitness <- vapply(seq_len(nrow(data.pop)),
                               function(k) {
                                 result <- try(mod.run(
                                   r                = ga.iter,
                                   dat              = dat,
                                   search.space     = search.space,
                                   string           = parseCode(string = population[k, 1:nbits], search.space = search.space),
                                   param_table      = param_table,
                                   penalty.control  = penalty.control,
                                   precomputed_results_file = precomputed_results_file,
                                   filename         = filename,
                                   ...
                                 ),
                                 silent = TRUE)
                                 if (is.numeric(result) && length(result) == 1)
                                   result
                                 else
                                   NA_real_
                               },
                               numeric(1))

    # Rank individuals
    data.pop$rank <- rank_new(data.pop$fitness, sig.diff)

    # 4. Chromosome selection
    data.pop$local.num <- seq_len(nrow(data.pop))
    sel.best <- data.pop[data.pop$rank == min(data.pop$rank),][1,]
    sel.best <- as.numeric(sel.best$local.num)
    sel.best.code <- population[sel.best, , drop = FALSE]

    # 5. Local exhaustive search
    ls.population <- NULL
    if (ga.iter %% nlocal.search == 0) {
      ls.population <- runlocal(
        ga.iter                   = ga.iter,
        dat                       = dat,
        search.space              = search.space,
        sel.best.code             = sel.best.code,
        sig.diff                  = sig.diff,
        param_table               = param_table,
        penalty.control           = penalty.control,
        precomputed_results_file  = precomputed_results_file,
        filename                  = filename,
        bit.names                 = bit.names,
        ...
      )
      if (min(data.pop$fitness, na.rm = TRUE) > min(ls.population$fitness, na.rm = TRUE)) {
        sel.best <-
          as.numeric(rownames(ls.population[ls.population$rank == min(ls.population$rank), ][1, ]))
        ls.population2 <- data.matrix(ls.population[, 1:nbits])
        sel.best.code <- ls.population2[sel.best, , drop = FALSE]
      }
    }

    # 6. Selection (tournament)
    sel.population <-
      ga.sel.tournament(data.pop = data.pop, population=population, npopsize=npopsize, nbits=nbits)

    # 7. Crossover
    children.cross <-
      ga.crossover(sel.population=sel.population,
                   prob.crossover=prob.crossover,
                   npopsize=npopsize,
                   nbits=nbits,
                   bit.names=bit.names)

    children.cross <- t(apply(children.cross, 1, function(x) {
      validateModels(
        string       = x,
        search.space = search.space,
        code.source  = "GA"
      )
    }))


    # 8. Mutation
    children.mutation <-
      ga.mutation(children.cross=children.cross,
                  prob.mutation=prob.mutation)

    children.mutation <- t(apply(children.mutation, 1, function(x) {
      validateModels(
        string       = x,
        search.space = search.space,
        code.source  = "GA"
      )
    }))


    # 9. Elitism: Keep best model in next generation
    children.all <- rbind(children.mutation[1:(nrow(children.mutation) - 1),],
                          sel.best.code)
    rownames(children.all) <- seq_len(nrow(children.all))


    # 10. Save results to history
    history[[ga.iter]] <- list(
      iteration              = ga.iter,
      population        = population,
      data.pop          = data.pop,
      sel.best.code     = sel.best.code,
      sel.population    = sel.population,
      ls.population     = ls.population,
      children.cross    = children.cross,
      children.mutation = children.all
    )
    pb$tick()
  }

  # ----------------------------
  # Final output
  # ----------------------------
  names(sel.best.code) <- bit.names
  best_model_name <- CodetoMod(sel.best.code = parseCode(sel.best.code,search.space=search.space),search.space=search.space)


  out <- new.env(parent = emptyenv())
  class(out) <- "gaOperatorResult"
  out[["Final Selected Code"]] <- as.data.frame(sel.best.code)
  out[["Final Selected Model Name"]] <- best_model_name
  out[["Model Run History"]] <- as.data.frame(Store.all, stringsAsFactors = FALSE)
  out[["Selection History"]] <- history

  on.exit({
  rm(modi, r, Store.all, precomputed_cache_loaded, envir = .GlobalEnv)
  }, add = TRUE)

  return(out)
}


#' Print method for gaOperatorResult objects
#'
#' Custom print method for results returned by the GA operator.
#' Displays only:
#'   - Final selected model code
#'   - Final selected model name
#'
#' @param x An object containing GA operator output (class gaOperatorResult).
#' @param ... Additional arguments (currently unused).
#'
#' @return Invisibly returns the input object.
#' @export
print.gaOperatorResult <- function(x, ...) {
  # Print final selected model code
  cat(crayon::green$bold("\n=== Final Selected Model Code ===\n"))
  print(x$`Final Selected Code`)

  # Print final selected model name
  cat(crayon::green$bold("\n=== Final Selected Model Name ===\n"))
  cat(x$`Final Selected Model Name`, "\n")

  invisible(x)
}













