#' Perform 1-bit local search around a selected GA model
#'
#' Performs a local search in the model space by flipping each bit
#' in the selected model code (binary vector) one at a time and evaluating the
#' resulting candidate models. Special handling is applied for bits representing
#' linked binary encodings (e.g., `no.cmpt1`/`no.cmpt2` and `rv1`/`rv2`).
#'
#' @param dat Data frame of observations (columns as required by \pkg{nlmixr2}/\pkg{rxode2},
#'   e.g., `ID`, `TIME`, `DV`, dosing records with `EVID`, etc.).
#' @param ga.iter Integer. GA iteration number (passed through to \code{mod.run}).
#' @param search.space Character. Either `"ivbase"` (intravenous) or `"oralbase"` (oral).
#'   Determines how the binary code is parsed into a categorical model structure.
#' @param sel.best.code Numeric/integer vector of 0/1 values representing the selected
#'   model's binary encoding. Must be the same length as `bit.names`.
#' @param sig.diff Numeric. Minimum significant difference in fitness for ranking.
#'   Passed to \code{rank_new()}.
#' @param param_table Data frame of initial parameter estimates. If \code{NULL},
#'   it will be generated by \code{\link{auto_param_table}()}.
#' @param penalty.control List created by \code{\link{penaltyControl}()} defining penalties
#'   for model evaluation.
#' @param precomputed_results_file Character or \code{NULL}. Path to a CSV file of previously
#'   computed results for cache lookup.
#' @param filename Character. Base name (without `.csv`) to which results will be appended.
#' @param bit.names Character vector of bit names in the correct order for the binary encoding.
#'   This is used to detect and handle linked bits (e.g., `no.cmpt1`/`no.cmpt2`).
#' @param ... Additional arguments passed to \code{\link{mod.run}()}.
#'
#' @details
#' For each bit in \code{sel.best.code}, the function flips its value and evaluates the new
#' model. If the bit corresponds to the second element of a linked pair (e.g., `no.cmpt2` or
#' `rv2`), the linked first bit is set to 1 and the second to 0 to maintain valid encoding.
#' All candidate models are validated via \code{\link{validateModels}()} before evaluation.
#'
#' Fitness for each candidate is computed by calling \code{\link{mod.run}()} and ranked
#' using \code{\link{rank_new}()}.
#'
#' @return
#' A data frame of candidate models with their binary/categorical encodings, computed fitness,
#' and rank.
#'
#' @seealso
#' \code{\link{mod.run}}, \code{\link{validateModels}}, \code{\link{auto_param_table}}
#'
#' @examples
#' \dontrun{
#' # Define bit names for ivbase (12 bits)
#' bit.names <- c(
#'   "no.cmpt1", "no.cmpt2",
#'   "eta.km", "eta.vc", "eta.vp", "eta.vp2", "eta.q", "eta.q2",
#'   "mm", "mcorr", "rv1", "rv2"
#' )
#'
#' # Example best model binary code
#' sel.best.code <- c(1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0)
#'
#' # Load example dataset
#' dat <- pheno_sd
#'
#' # Generate parameter table
#' param_table <- auto_param_table(dat = dat, nlmixr2autoinits = TRUE)
#'
#' # Run local search
#' res_local <- runlocal(
#'   dat                      = dat,
#'   ga.iter                  = 1,
#'   search.space             = "ivbase",
#'   sel.best.code            = sel.best.code,
#'   sig.diff                 = 1,
#'   param_table              = param_table,
#'   penalty.control          = penaltyControl(),
#'   filename                 = "local_search_results",
#'   bit.names                = bit.names
#' )
#'
#' print(res_local)
#' }
#' @export

runlocal <- function(dat,
                     ga.iter = 1,
                     search.space = "ivbase",
                     sel.best.code = NULL,
                     sig.diff = 1,
                     param_table = NULL,
                     penalty.control = penaltyControl(),
                     precomputed_results_file = NULL,
                     filename,
                     bit.names = NULL,
                     ...) {

  # Defensive checks

  if (is.null(bit.names))  {
    stop(sprintf(
      "'bit.names' cannot be NULL"
    ))
  }

  if (search.space == "oralbase") {
    idx_eta_q2 <- which(bit.names == "eta.q2")
    if (length(idx_eta_q2) == 1) {
      bit.names <- append(bit.names, "eta.ka", after = idx_eta_q2)
    } else {
      warning("'eta.q2' not found in bit.names, 'eta.ka' not inserted.")
    }
  }

  nbits <- length(bit.names)
  if (is.null(sel.best.code)) {
    stop("'sel.best.code' cannot be NULL. Please provide a binary vector.")
  }
  if (is.null(nbits)) {
    stop("'nbits' must be specified.")
  }
  if (length(sel.best.code) !=  nbits) {
    stop(sprintf(
      "'sel.best.code' length (%d) does not match 'nbits' (%d).",
      length(sel.best.code),
      nbits
    ))
  }

  if (is.null(names(sel.best.code)) ||
      any(names(sel.best.code) == "")) {
    names(sel.best.code) <- bit.names
  }

  param_table <- auto_param_table(
    dat = dat,
    param_table = param_table,
    nlmixr2autoinits = T,
    foldername = foldername
  )

  # Generate local search population
  ls.population <- NULL

  for (ls.cycle in seq_len(length(sel.best.code))) {
    # Flip current bit from 0->1 or 1->0
    ls.population.s <- sel.best.code
    ls.population.s[ls.cycle] <-
      ifelse(sel.best.code[ls.cycle] == 0, 1, 0)

    # Special handling for no.cmpt (bits affecting compartment number)
    if (bit.names[ls.cycle] == "no.cmpt2") {
      idx_prev <- which(bit.names == "no.cmpt1")
      if (sel.best.code[idx_prev] == 0) {
        ls.population.s <- sel.best.code
        ls.population.s[ls.cycle] <- 0
        ls.population.s[idx_prev] <- 1
      }
    }

    # Special handling for rv (bits affecting residual error model)
    if (bit.names[ls.cycle] == "rv2") {
      idx_prev <- which(bit.names == "rv1")
      if (sel.best.code[idx_prev] == 0) {
        ls.population.s <- sel.best.code
        ls.population.s[ls.cycle] <- 0
        ls.population.s[idx_prev] <- 1
      }
    }

    # Decode to categorical code using validateModels
    ls.population.s <- validateModels(ls.population.s,
                                      search.space = search.space,
                                      code.source  = "GA")
    ls.population <- rbind(ls.population, ls.population.s)
  }

  # Remove duplicates and initialize fitness
  ls.population <- as.data.frame(ls.population)
  ls.population <- unique(ls.population)
  ls.population$fitness <- NA_real_

  # Evaluate each candidate model
  ls.population$fitness <- vapply(seq_len(nrow(ls.population)),
                                  function(k) {
                                    result <- try(mod.run(
                                      r                        = ga.iter,
                                      dat                      = dat,
                                      search.space             = search.space,
                                      string                   = parseCode(ls.population[k, 1:nbits], search.space),
                                      param_table              = param_table,
                                      penalty.control          = penalty.control,
                                      precomputed_results_file = precomputed_results_file,
                                      filename                 = filename,
                                      ...
                                    ),
                                    silent = TRUE)

                                    if (is.numeric(result) &&
                                        length(result) == 1)
                                      result
                                    else
                                      NA_real_
                                  },
                                  numeric(1))

  # Rank models based on fitness
  ls.population$rank <- rank_new(ls.population$fitness, sig.diff)
  colnames(ls.population)[seq_len(length(bit.names))] <- bit.names
  rownames(ls.population) <- NULL

  return(ls.population)
}
