#' Run an nlmixr2 model in an isolated subprocess
#'
#' This function executes an nlmixr2 model fitting procedure in a separate
#' background R session using the \pkg{processx} backend.
#' Running the model in an isolated subprocess prevents the main R session from
#' crashing and allows monitoring errors, wall-time limits, and controlled output.
#'
#' Temporary files are created to pass model components (`f`, `dat`,
#' `saem.control`, `table.control`) to the subprocess and to retrieve the fitted
#' model object.
#'
#' @param modi Integer. A model index used to generate unique temporary filenames.
#' @param dat A data frame containing the dataset used in nlmixr2 model fitting.
#' @param f An nlmixr2 model function (e.g., generated by \code{ppkmodGen(..., return.func = TRUE)}).
#' @param saem.control A \code{saemControl()} object providing estimation settings.
#' @param table.control A \code{tableControl()} object controlling table output behavior.
#' @param max_errors Integer. Maximum number of detected error messages before
#'   forcibly terminating the subprocess. Default is 100.
#' @param max_wall_time Numeric (seconds). Maximum allowed real (wall-clock)
#'   time for the subprocess before termination. Default is 86400 (24 hours).
#' @param verbose Logical. If TRUE, progress and diagnostic messages are
#'   printed during subprocess monitoring. Default is TRUE.
#'
#' @return A list with:
#' \describe{
#'   \item{fit.s}{The fitted nlmixr2 object, or NULL if the subprocess failed.}
#'   \item{loadError}{Logical indicating whether an error occurred (including timeout or crash).}
#' }
#'
#' @details
#' The function uses \pkg{processx} to execute a temporary R script in a clean R
#' process. This provides isolation from instabilities that may arise during
#' long-running nlmixr2/SAEM estimation routines, as well as from poorly
#' specified or unstable models that can otherwise cause the main R session to
#' crash. Running each fit in a separate subprocess helps ensure that estimation
#' failures remain contained and do not interrupt the user's primary workflow.
#'
#' Error messages emitted by the subprocess are monitored in real time, and the
#' process is automatically terminated if:
#' \enumerate{
#'   \item Too many errors are detected (\code{max_errors});
#'   \item The wall-time limit (\code{max_wall_time}) is exceeded
#' }
#'
#' @examples
#' # Example: run a simple nlmixr2 model
#' pheno <- function() {
#'   ini({
#'     tcl <- log(0.008)     # typical clearance
#'     tv  <- log(0.6)       # typical volume
#'     eta.cl + eta.v ~ c(1,
#'                        0.01, 1)  # interindividual variability
#'     add.err <- 0.1        # residual variability
#'   })
#'
#'   model({
#'     cl <- exp(tcl + eta.cl)
#'     v  <- exp(tv  + eta.v)
#'     ke <- cl / v
#'     d/dt(A1) = -ke * A1
#'     cp = A1 / v
#'     cp ~ add(add.err)
#'   })
#' }
#' \donttest{
#'  run_model_in_subprocess(
#'     modi = 1,
#'     dat = pheno_sd,
#'     f = pheno,
#'     saem.control = saemControl(
#'       seed = 1234,
#'       nBurn = 100,
#'       nEm = 100,
#'       logLik = TRUE
#'     )
#'   )
#' }
#' @export

run_model_in_subprocess <- function(modi,
                                    dat,
                                    f,
                                    saem.control = NULL,
                                    table.control = NULL,
                                    max_errors = 100,
                                    max_wall_time = 86400,
                                    verbose = TRUE) {
  # Required package
  if (!requireNamespace("processx", quietly = TRUE)) {
    stop(
      "The 'processx' package is required. Please install it via install.packages('processx')."
    )
  }

  # Define temporary filenames
  temp_model_data <- paste0("temp_model_data_", modi, ".rds")
  temp_fit_result <- paste0("temp_fit_result_", modi, ".rds")
  temp_script <- paste0("temp_script_", modi, ".R")

  # Save model components to RDS
  saveRDS(
    list(
      f = f,
      dat = dat,
      saem.control = saem.control,
      table.control = table.control
    ),
    file = temp_model_data
  )

  # Create temporary R script for subprocess
  script_content <- sprintf(
    '
  suppressMessages({
    library(rxode2)
    library(nlmixr2)
  })

  model_data <- readRDS("%s")
  f <- model_data$f
  dat <- model_data$dat
  saem.control <- model_data$saem.control
  table.control <- model_data$table.control

  fit_result <- tryCatch({
    nlmixr2(
      f,
      dat,
      est = "saem",
      control = saem.control,
      table = table.control
    )
  }, error = function(e) {
    NULL
  })

  saveRDS(fit_result, "%s")
  ',
    temp_model_data,
    temp_fit_result
  )

  # Write to script file
  writeLines(script_content, temp_script)

  # Launch subprocess
  p <-
    processx::process$new(
      "Rscript",
      c(temp_script),
      stdout = "|",
      stderr = "|",
      supervise = TRUE
    )

  # Real-time monitoring
  error_count <- 0
  loadError <- FALSE
  start_time <- Sys.time()

  while (p$is_alive()) {
    lines_out <- p$read_output_lines()
    lines_err <- p$read_error_lines()

    for (line in c(lines_out, lines_err)) {
      if (grepl("unhandled error message:", line)) {
        error_count <- error_count + 1
        if (verbose) {
          message(sprintf(
            "Model %d: Error detected %d/%d",
            modi,
            error_count,
            max_errors
          ))
        }
        if (error_count >= max_errors) {
          p$kill()
          if (verbose) {
            message(sprintf(
              "Model %d: Wall-time limit exceeded. Terminated.",
              modi
            ))
          }
          loadError <- TRUE
          break
        }
      }
    }

    if (as.numeric(difftime(Sys.time(), start_time, units = "secs")) >
        max_wall_time) {
      p$kill()
      if (verbose) {
        message(sprintf("Model %d: Wall-time limit exceeded. Terminated.", modi))
      }
      loadError <- TRUE
      break
    }

    Sys.sleep(0.1)
  }

  # Load results
  if (file.exists(temp_fit_result)) {
    fit.s <- readRDS(temp_fit_result)
  } else {
    fit.s <- NULL
    loadError <- TRUE
  }

  # Clean up
  unlink(c(temp_model_data, temp_fit_result, temp_script))

  return(list(fit.s = fit.s, loadError = loadError))
}
